#ifndef _EVALUATOR_H_
#define _EVALUATOR_H_

#include "State.h"
#include "Move.h"
#include <vector>

/* 估值器，提供对每一个局面状态的下特定走法的评分 */
/* 使用先验知识和一些局面评估因素为局面估值 */
class Evaluator
{
public:
	/* 评估结点计数 */
	unsigned cnt;
	/* 估值器构造函数，初始化估值器 */
	Evaluator();
	/* 估值函数，对给定的局面状态评分 */
	int evaluate(State &state);
private:
	/* 炮的一些重要坐标的加成 */
	const int ADD_R_CANNON[10][9] =
	{
		{50,	50,	0,	0,	0,	0,	0,	50,	50},
		{0,	0,	0,	0,	0,	0,	0,	0,	0},
		{0,	0,	0,	10,	0,	10,	0,	0,	0},
		{0,	0,	0,	0,	0,	0,	0,	0,	0},
		{0,	0,	0,	0,	0,	0,	0,	0,	0},
		{0,	10,	0,	0,	0,	0,	0,	10,	0},
		{0,	0,	0,	0,	0,	0,	0,	0,	0},
		{10,	0,	0,	10,	50,	10,	0,	0,	10},
		{0,	0,	0,	0,	0,	0,	0,	0,	0},
		{0,	0,	0,	0,	0,	0,	0,	0,	0}
	};
	const int ADD_B_CANNON[10][9] =
	{
		{0,	0,	0,	0,	0,	0,	0,	0,	0},
		{0,	0,	0,	0,	0,	0,	0,	0,	0},
		{10,	0,	0,	10,	50,	10,	0,	0,	10},
		{0,	0,	0,	0,	0,	0,	0,	0,	0},
		{0,	10,	0,	0,	0,	0,	0,	10,	0},
		{0,	0,	0,	0,	0,	0,	0,	0,	0},
		{0,	0,	0,	0,	0,	0,	0,	0,	0},
		{0,	0,	0,	10,	0,	10,	0,	0,	0},
		{0,	0,	0,	0,	0,	0,	0,	0,	0},
		{50,	50,	0,	0,	0,	0,	0,	50,	50}
	};
	/* 马的一些重要坐标的加成 */
	const int ADD_R_KNIGHT[10][9] =
	{
		{0,	0,	0,	0,	0,	0,	0,	0,	0},
		{0,	0,	100,	0,	0,	0,	100,	0,	0},
		{0,	0,	0,	100,	0,	100,	0,	0,	0},
		{0,	0,	0,	0,	0,	0,	0,	0,	0},
		{0,	0,	0,	0,	0,	0,	0,	0,	0},
		{0,	0,	10,	0,	0,	0,	10,	0,	0},
		{0,	0,	0,	0,	0,	0,	0,	0,	0},
		{0,	0,	10,	0,	0,	0,	10,	0,	0},
		{0,	0,	0,	0,	-100,	0,	0,	0,	0},
		{0,	0,	0,	0,	0,	0,	0,	0,	0}
	};
	const int ADD_B_KNIGHT[10][9] =
	{
		{0,	0,	0,	0,	0,	0,	0,	0,	0},
		{0,	0,	0,	0,	-100,	0,	0,	0,	0},
		{0,	0,	10,	0,	0,	0,	10,	0,	0},
		{0,	0,	0,	0,	0,	0,	0,	0,	0},
		{0,	0,	10,	0,	0,	0,	10,	0,	0},
		{0,	0,	0,	0,	0,	0,	0,	0,	0},
		{0,	0,	0,	0,	0,	0,	0,	0,	0},
		{0,	0,	0,	100,	0,	100,	0,	0,	0},
		{0,	0,	100,	0,	0,	0,	100,	0,	0},
		{0,	0,	0,	0,	0,	0,	0,	0,	0}
	};
	/* 兵的一些重要坐标的加成 */
	const int ADD_R_PAWN[10][9] =
	{
		{0,	0,	0,	0,	0,	0,	0,	0,	0},
		{90,	90,	110,	120,	120,	120,	110,	90,	90},
		{90,	90,	110,	120,	120,	120,	110,	90,	90},
		{70,	90,	110,	120,	120,	120,	110,	90,	70},
		{70,	70,	70,	70,	70,	70,	70,	70,	70},
		{0,	0,	0,	0,	0,	0,	0,	0,	0},
		{0,	0,	0,	0,	0,	0,	0,	0,	0},
		{0,	0,	0,	0,	0,	0,	0,	0,	0},
		{0,	0,	0,	0,	0,	0,	0,	0,	0},
		{0,	0,	0,	0,	0,	0,	0,	0,	0}
	};
	const int ADD_B_PAWN[10][9] =
	{
		{0,	0,	0,	0,	0,	0,	0,	0,	0},
		{0,	0,	0,	0,	0,	0,	0,	0,	0},
		{0,	0,	0,	0,	0,	0,	0,	0,	0},
		{0,	0,	0,	0,	0,	0,	0,	0,	0},
		{0,	0,	0,	0,	0,	0,	0,	0,	0},
		{70,	70,	70,	70,	70,	70,	70,	70,	70},
		{70,	90,	110,	120,	120,	120,	110,	90,	70},
		{90,	90,	110,	120,	120,	120,	110,	90,	90},
		{90,	90,	110,	120,	120,	120,	110,	90,	90},
		{0,	0,	0,	0,	0,	0,	0,	0,	0}
	};
	/* 先验的定义每种棋子的基本价值 */
	const int BASE_VAL[32] =
	{
		10000, 250, 250, 250, 250, 350, 350, 500, 500, 350, 350, 100, 100, 100, 100, 100,
		10000, 250, 250, 250, 250, 350, 350, 500, 500, 350, 350, 100, 100, 100, 100, 100
	};
	/* 棋子灵活度单位价值，即每个可走位置对总自由度的贡献 */
	const int FREE_UNIT[32] =
	{
		0, 1, 1, 1, 1, 12, 12, 6, 6, 6, 6, 15, 15, 15, 15, 15,
		0, 1, 1, 1, 1, 12, 12, 6, 6, 6, 6, 15, 15, 15, 15, 15
	};
	/* 棋子被威胁造成的负分 */
	bool threatenScore[32];
	/* 棋子被保护造成的加分 */
	bool protectScore[32];
	/* 棋子评分 */
	int chessScore[32];
	/* 根据特定的局面状态和当前行动权归属生成所有可能的势力覆盖方式并填充走法容器 */
	void generate(const State &state);
	/* 棋子势力覆盖方式容器 */
	std::vector<Move> coverList;
};

#endif
